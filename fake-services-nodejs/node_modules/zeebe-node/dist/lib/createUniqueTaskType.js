"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createUniqueTaskType = void 0;
const fs_1 = require("fs");
const uuid_1 = require("uuid");
// Replace a tasktype in a bpmn model with a unique tasktype
// This deals with stateful tests
function createUniqueTaskType({ bpmnFilePath, taskTypes, messages, }) {
    const bpmn = fs_1.readFileSync(bpmnFilePath, 'utf8');
    const newTaskTypes = taskTypes.map(t => ({ [t]: uuid_1.v4() }));
    const newMessages = messages.map(m => ({ [m]: uuid_1.v4() }));
    const replacedTasks = newTaskTypes.length > 0
        ? newTaskTypes.reduce((p, c) => p
            .split(`<zeebe:taskDefinition type="${Object.keys(c)[0]}`)
            .join(`<zeebe:taskDefinition type="${c[Object.keys(c)[0]]}`), bpmn)
        : bpmn;
    const replacedMessages = newMessages
        ? newMessages.reduce((p, c) => p.split(Object.keys(c)[0]).join(c[Object.keys(c)[0]]), replacedTasks)
        : replacedTasks;
    const processIdPieces = replacedMessages.split('<bpmn:process id="');
    const endOfProcessId = processIdPieces[1].indexOf('"');
    const secondHalf = processIdPieces[1].substr(endOfProcessId);
    const newProcessId = `process-${uuid_1.v4()}`;
    const renamedProcess = processIdPieces[0].concat('<bpmn:process id="', newProcessId, secondHalf);
    const taskTypesMap = newTaskTypes.reduce((p, c) => ({ ...p, ...c }), {});
    const messagesMap = newMessages.reduce((p, c) => ({ ...p, ...c }), {});
    return {
        bpmn: Buffer.from(renamedProcess),
        messages: messagesMap,
        processId: newProcessId,
        taskTypes: taskTypesMap,
    };
}
exports.createUniqueTaskType = createUniqueTaskType;
//# sourceMappingURL=createUniqueTaskType.js.map