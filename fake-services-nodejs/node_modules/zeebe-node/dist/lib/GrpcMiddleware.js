"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcMiddleware = void 0;
const ZBClient_1 = require("../zb/ZBClient");
const GrpcClient_1 = require("./GrpcClient");
class GrpcMiddleware {
    constructor({ characteristics, config, log, }) {
        this.getGrpcClient = () => this.grpcClient;
        this.emitError = () => this.grpcClient.emit(ZBClient_1.ConnectionStatusEvent.connectionError);
        this.emitReady = () => this.grpcClient.emit(ZBClient_1.ConnectionStatusEvent.ready);
        this.handleExceptionalGrpc = ({ callStatus, options, }) => {
            if (options.method_definition.path === 'not-happening') {
                this.log.logDebug('This is to stop the compiler choking on an unused parameter while I figure out which cases to handle.');
            }
            if (callStatus.code === 1 && callStatus.details.includes('503')) {
                this.log.logError('The gateway returned HTTP Error 503 (Bad Gateway). This can be a transient failure while a Kubernetes node in Camunda Cloud is being pre-empted.');
            }
        };
        this.characteristics = characteristics;
        this.blocking = this.characteristics.startupTime > 0;
        this.state = 'UNKNOWN';
        log.logDebug(`Grpc Middleware blocking: ${this.blocking}`);
        if (this.blocking) {
            this.blockingTimer = setTimeout(() => {
                this.blocking = false;
                log.logDebug(`Grpc Middleware state: ${this.state}`);
                if (this.state === 'ERROR') {
                    this.emitError();
                }
                else if (this.state === 'CONNECTED') {
                    this.emitReady();
                }
                else if (this.state === 'UNKNOWN') {
                    this.grpcClient.emit(ZBClient_1.ConnectionStatusEvent.unknown);
                }
            }, this.characteristics.startupTime);
        }
        this.log = log;
        this.grpcClient = this.createInterceptedGrpcClient(config);
    }
    createInterceptedGrpcClient(config) {
        const grpcClient = new GrpcClient_1.GrpcClient(config);
        const logInterceptor = this.log;
        const _close = grpcClient.close.bind(grpcClient);
        grpcClient.close = async () => {
            if (this.blockingTimer) {
                clearTimeout(this.blockingTimer);
            }
            _close();
            return null;
        };
        grpcClient.on(GrpcClient_1.MiddlewareSignals.Log.Debug, logInterceptor.logDebug);
        grpcClient.on(GrpcClient_1.MiddlewareSignals.Log.Info, logInterceptor.logInfo);
        grpcClient.on(GrpcClient_1.MiddlewareSignals.Log.Error, logInterceptor.logError);
        grpcClient.on(GrpcClient_1.MiddlewareSignals.Event.Error, () => {
            this.state = 'ERROR';
            logInterceptor.connectionError();
            if (!this.blocking) {
                this.emitError();
            }
        });
        grpcClient.on(GrpcClient_1.MiddlewareSignals.Event.Ready, () => {
            this.state = 'CONNECTED';
            logInterceptor.ready();
            if (!this.blocking) {
                this.emitReady();
                logInterceptor.logDebug(`Middleware emits ready`);
            }
            else {
                logInterceptor.logDebug(`Blocked ready emit`);
            }
        });
        grpcClient.on(GrpcClient_1.MiddlewareSignals.Event.GrpcInterceptError, this.handleExceptionalGrpc);
        return grpcClient;
    }
}
exports.GrpcMiddleware = GrpcMiddleware;
//# sourceMappingURL=GrpcMiddleware.js.map