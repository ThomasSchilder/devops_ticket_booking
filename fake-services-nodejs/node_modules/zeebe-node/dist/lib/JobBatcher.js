"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JobBatcher = void 0;
const Queue_1 = require("./Queue");
class JobBatcher {
    constructor({ handler, timeout, batchSize, worker, }) {
        this.batchedJobs = new Queue_1.Queue();
        this.handler = handler;
        this.timeout = timeout;
        this.batchSize = batchSize;
        this.worker = worker;
    }
    batch(batch) {
        if (!this.batchExecutionTimerHandle) {
            this.batchExecutionTimerHandle = setTimeout(() => this.execute(), this.timeout * 1000);
        }
        batch.forEach(this.batchedJobs.push);
        if (this.batchedJobs.length() >= this.batchSize) {
            clearTimeout(this.batchExecutionTimerHandle);
            this.execute();
        }
    }
    execute() {
        this.batchExecutionTimerHandle = undefined;
        this.worker.debug(`Executing batched handler with ${this.batchedJobs.length()} jobs`);
        try {
            this.handler(this.batchedJobs.drain(), this.worker);
        }
        catch (e) {
            this.worker.error(`An unhandled exception occurred in the worker task handler!`);
            this.worker.error(e.message);
            this.worker.error(e);
        }
    }
}
exports.JobBatcher = JobBatcher;
//# sourceMappingURL=JobBatcher.js.map