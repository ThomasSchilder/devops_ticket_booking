import { Chalk } from 'chalk';
import { MaybeTimeDuration } from 'typed-duration';
import * as ZB from '../lib/interfaces-1.0';
import { StatefulLogInterceptor } from '../lib/StatefulLogInterceptor';
import { ConnectionStatusEvent, ZBClient } from '../zb/ZBClient';
import { ZBClientOptions } from './interfaces-published-contract';
import { TypedEmitter } from './TypedEmitter';
export interface ZBWorkerBaseConstructor<T> {
    grpcClient: ZB.ZBGrpc;
    id: string | null;
    taskType: string;
    options: ZB.ZBWorkerOptions<T> & ZBClientOptions;
    idColor: Chalk;
    zbClient: ZBClient;
    log: StatefulLogInterceptor;
}
export interface ZBBatchWorkerConstructorConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables> extends ZBWorkerBaseConstructor<WorkerInputVariables> {
    options: ZB.ZBWorkerOptions<WorkerInputVariables> & ZBClientOptions & {
        jobBatchMaxTime: number;
    };
    taskHandler: ZB.ZBBatchWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
}
export interface ZBWorkerConstructorConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables> extends ZBWorkerBaseConstructor<WorkerInputVariables> {
    taskHandler: ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
}
export declare class ZBWorkerBase<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables> extends TypedEmitter<typeof ConnectionStatusEvent> {
    private static readonly DEFAULT_JOB_ACTIVATION_TIMEOUT;
    private static readonly DEFAULT_MAX_ACTIVE_JOBS;
    activeJobs: number;
    grpcClient: ZB.ZBGrpc;
    maxJobsToActivate: number;
    jobBatchMinSize: number;
    taskType: string;
    timeout: MaybeTimeDuration;
    pollCount: number;
    protected zbClient: ZBClient;
    protected logger: StatefulLogInterceptor;
    protected taskHandler: ZB.ZBBatchWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables> | ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    protected cancelWorkflowOnException: boolean;
    private closeCallback?;
    private closePromise?;
    private closing;
    private closed;
    private id;
    private longPoll;
    private debugMode;
    private capacityEmitter;
    private stalled;
    private connected;
    private readied;
    private jobStream?;
    private activeJobsThresholdForReactivation;
    private pollInterval;
    private pollLoop;
    private pollMutex;
    private backPressureRetryCount;
    constructor({ grpcClient, id, log, options, taskHandler, taskType, zbClient, }: ZBBatchWorkerConstructorConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables> | ZBWorkerConstructorConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>);
    /**
     * Returns a promise that the worker has stopped accepting tasks and
     * has drained all current active tasks. Will reject if you try to call it more than once.
     */
    close(timeout?: number): Promise<null>;
    log(msg: any): void;
    debug(msg: any): void;
    error(msg: any): void;
    protected drainOne(): void;
    protected handleJobs(_: ZB.Job[]): void;
    protected makeCompleteHandlers<T>(thisJob: ZB.Job): ZB.CompleteFn<T> & ZB.JobCompletionInterface<T>;
    private failJob;
    private completeJob;
    private errorJob;
    private handleStreamEnd;
    private poll;
    private activateJobs;
    private handleJobResponse;
}
